/*** Generated by streamline 0.10.17 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; var __ = require("underscore");















var util = require("util");
var utils = require("../../../util/utils");
var $ = utils.getLocaleString;
var resourceUtils = require("../resource/resourceUtils");
var tagUtils = require("../tag/tagUtils");

function PublicIp(cli, networkResourceProviderClient) {
  this.networkResourceProviderClient = networkResourceProviderClient;
  this.output = cli.output;
  this.interaction = cli.interaction;};


__.extend(PublicIp.prototype, {
  create: function create__1(resourceGroupName, name, options, _) { var self, publicipProfile, publicip, progress, __this = this; var __frame = { name: "create__1", line: 30 }; return __func(_, this, arguments, create__1, 3, __frame, function __$create__1() { self = __this;

      publicipProfile = self._parsePublicIP(name, options);

      return self.get(resourceGroupName, name, __cb(_, __frame, 4, 24, function ___(__0, __1) { publicip = __1;
        if (publicip) {
          return _(new Error(util.format($("A public ip address with name \"%s\" already exists in the resource group \"%s\""), name, resourceGroupName))); } ;


        progress = self.interaction.progress(util.format($("Creating public ip address \"%s\""), name)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$create__1() {

              return self.networkResourceProviderClient.publicIpAddresses.createOrUpdate(resourceGroupName, name, publicipProfile, __cb(_, __frame, 11, 59, function __$create__1() { _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$create__1() {

                progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$create__1() {

            return self.show(resourceGroupName, name, options, __cb(_, __frame, 15, 9, function __$create__1() { _(); }, true)); }); }); }, true)); }); },


  set: function set__2(resourceGroupName, name, options, _) { var self, publicipProfile, publicip, optionalDomainLabel, optionalReverseFqdn, __this = this; var __frame = { name: "set__2", line: 48 }; return __func(_, this, arguments, set__2, 3, __frame, function __$set__2() { self = __this;

      publicipProfile = self._parsePublicIP(name, options);

      return self.get(resourceGroupName, name, __cb(_, __frame, 4, 24, function ___(__0, __1) { publicip = __1;
        if (!publicip) {
          return _(new Error(util.format($("A public ip address with name \"%s\" not found in the resource group \"%s\""), name, resourceGroupName))); } ;


        if (options.idletimeout) { publicip.idleTimeoutInMinutes = publicipProfile.idleTimeoutInMinutes; } ;
        if (options.allocationMethod) { publicip.publicIpAllocationMethod = publicipProfile.publicIpAllocationMethod; } ;

        optionalDomainLabel = utils.getOptionalArg(options.domainNameLabel);
        if (optionalDomainLabel.hasValue) {
          if ((optionalDomainLabel.value !== null)) {
            self._createDnsSettingsIfNotExist(publicip);
            publicip.dnsSettings.domainNameLabel = publicipProfile.dnsSettings.domainNameLabel; }
           else {
            delete publicip.dnsSettings; } ; } ;



        optionalReverseFqdn = utils.getOptionalArg(options.reverseFqdn);
        if (optionalReverseFqdn.hasValue) {
          if ((optionalReverseFqdn.value !== null)) {
            self._createDnsSettingsIfNotExist(publicip);
            publicip.dnsSettings.reverseFqdn = publicipProfile.dnsSettings.reverseFqdn; }
           else {
            delete publicip.dnsSettings.reverseFqdn; } ; } ;



        if (options.tags) {
          tagUtils.appendTags(publicip, publicipProfile.tags); } ;


        if ((options.tags === false)) {
          publicip.tags = { }; } ;


        return self.update(resourceGroupName, name, publicip, __cb(_, __frame, 40, 9, function __$set__2() {
          return self.show(resourceGroupName, name, options, __cb(_, __frame, 41, 9, function __$set__2() { _(); }, true)); }, true)); }, true)); }); },


  show: function show__3(resourceGroupName, name, options, _) { var self, publicip, __this = this; var __frame = { name: "show__3", line: 92 }; return __func(_, this, arguments, show__3, 3, __frame, function __$show__3() { self = __this;

      return self.get(resourceGroupName, name, __cb(_, __frame, 2, 24, function ___(__0, __1) { publicip = __1;

        self.interaction.formatOutput(publicip, function(publicip) {
          if ((publicip === null)) {
            self.output.warn(util.format($("A public ip address with name \"%s\" not found in the resource group \"%s\""), name, resourceGroupName)); }
           else {
            var resourceInfo = resourceUtils.getResourceInformation(publicip.id);
            self.output.nameValue($("Id"), publicip.id);
            self.output.nameValue($("Name"), publicip.name);
            self.output.nameValue($("Type"), resourceInfo.resourceType);
            self.output.nameValue($("Location"), publicip.location);
            self.output.nameValue($("Provisioning state"), publicip.provisioningState);
            self.output.nameValue($("Tags"), tagUtils.getTagsInfo(publicip.tags));
            self.output.nameValue($("Allocation method"), publicip.publicIpAllocationMethod);
            self.output.nameValue($("Idle timeout"), publicip.idleTimeoutInMinutes);
            self.output.nameValue($("IP Address"), publicip.ipAddress);
            if (publicip.dnsSettings) {
              var dnsSettings = publicip.dnsSettings;
              self.output.nameValue($("Domain name label"), dnsSettings.domainNameLabel);
              self.output.nameValue($("FQDN"), dnsSettings.fqdn);
              self.output.nameValue($("Reverse FQDN"), dnsSettings.reverseFqdn); } ; } ; }); _(); }, true)); }); },





  delete: function delete__4(resourceGroupName, name, options, _) { var self, publicIP, progress, __this = this; var __frame = { name: "delete__4", line: 120 }; return __func(_, this, arguments, delete__4, 3, __frame, function __$delete__4() { self = __this;

      return self.get(resourceGroupName, name, __cb(_, __frame, 2, 24, function ___(__0, __2) { publicIP = __2;

        if (!publicIP) {
          return _(new Error(util.format($("A public ip address with name \"%s\" not found in the resource group \"%s\""), name, resourceGroupName))); } ; return (function __$delete__4(_) {


          var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return self.interaction.confirm(util.format($("Delete public ip address \"%s\"? [y/n] "), name), __cb(_, __frame, 8, 44, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -119, 17, function ___(__0, __3) { return (function __$delete__4(__then) { if (__3) { return _(null); } else { __then(); } ; })(function __$delete__4() {



            progress = self.interaction.progress(util.format($("Deleting public ip address \"%s\""), name)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$delete__4() {

                  return self.networkResourceProviderClient.publicIpAddresses.deleteMethod(resourceGroupName, name, __cb(_, __frame, 14, 59, function __$delete__4() { _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$delete__4() {

                    progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$delete__4() { _(); }); }); }); }, true)); }, true)); }); },



  list: function list__5(resourceGroupName, options, _) { var self, progress, publicIPs, __this = this; var __frame = { name: "list__5", line: 140 }; return __func(_, this, arguments, list__5, 2, __frame, function __$list__5() { self = __this;

      progress = self.interaction.progress($("Getting the public ip addresses"));

      publicIPs = null; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$list__5() {

            return self.networkResourceProviderClient.publicIpAddresses.list(resourceGroupName, __cb(_, __frame, 6, 71, function ___(__0, __1) { publicIPs = __1; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$list__5() {

              progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$list__5() {


          self.interaction.formatOutput(publicIPs.publicIpAddresses, function(data) {
            if ((data.length === 0)) {
              self.output.warn($("No public ip address found"));
              return; } ;

            self.output.table(data, function(row, publicip) {
              row.cell($("Name"), publicip.name);
              row.cell($("Location"), publicip.location);
              row.cell($("Allocation"), publicip.publicIpAllocationMethod);
              row.cell($("IP Address"), (publicip.ipAddress || ""));
              row.cell($("Idle timeout"), (publicip.idleTimeoutInMinutes || ""));
              var dnsName = "";
              if (publicip.dnsSettings) {
                dnsName = publicip.dnsSettings.fqdn; } ;

              row.cell($("DNS Name"), dnsName); }); }); _(); }); }); }); },




  get: function get__6(resourceGroupName, name, _) { var self, progress, publicIP, __this = this; var __frame = { name: "get__6", line: 171 }; return __func(_, this, arguments, get__6, 2, __frame, function __$get__6() { self = __this;

      progress = self.interaction.progress(util.format($("Looking up the public ip \"%s\""), name)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$get__6() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$get__6() {


                  return self.networkResourceProviderClient.publicIpAddresses.get(resourceGroupName, name, __cb(_, __frame, 5, 74, function ___(__0, __1) { publicIP = __1;
                    return _(null, publicIP.publicIpAddress); }, true)); }); })(function ___(e, __result) { __catch(function __$get__6() { if (e) {

                    if ((e.statusCode === 404)) {
                      return _(null, null); } ;

                    return _(e); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$get__6() { _(null, null, true); }); }); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$get__6() {

              progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$get__6() { _(); }); }); }); },



  update: function update__7(resourceGroupName, name, publicIpProfile, _) { var self, progress, __this = this; var __frame = { name: "update__7", line: 188 }; return __func(_, this, arguments, update__7, 3, __frame, function __$update__7() { self = __this;

      progress = self.interaction.progress(util.format($("Updating public ip address \"%s\""), name)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$update__7() {


            return self.networkResourceProviderClient.publicIpAddresses.createOrUpdate(resourceGroupName, name, publicIpProfile, __cb(_, __frame, 5, 59, function __$update__7() { _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$update__7() {

              progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$update__7() { _(); }); }); }); },



  _parsePublicIP: function(name, options) {
    var supportedAllocationTypes = ["Dynamic","Static",];
    var self = this;

    var publicipProfile = {
      name: name,
      publicIpAllocationMethod: supportedAllocationTypes[0] };


    if (options.idletimeout) {
      var timeoutAsInt = utils.parseInt(options.idletimeout);
      if ((isNaN(timeoutAsInt) || (timeoutAsInt === 0))) {
        throw new Error($("idletimeout parameter must be an integer")); } ;

      publicipProfile.idleTimeoutInMinutes = timeoutAsInt; } ;


    if (options.allocationMethod) {
      if (utils.stringIsNullOrEmpty(options.allocationMethod)) {
        throw new Error($("allocation method parameter must not be null or empty string")); } ;

      publicipProfile.publicIpAllocationMethod = utils.verifyParamExistsInCollection(supportedAllocationTypes, options.allocationMethod, "allocationMethod"); } ;



    if (options.domainNameLabel) {
      self._createDnsSettingsIfNotExist(publicipProfile);
      publicipProfile.dnsSettings.domainNameLabel = options.domainNameLabel; } ;


    if (options.reverseFqdn) {
      self._createDnsSettingsIfNotExist(publicipProfile);
      publicipProfile.dnsSettings.reverseFqdn = options.reverseFqdn; } ;


    if (options.tags) {
      publicipProfile.tags = tagUtils.buildTagsParameter(null, options); } ;


    if (options.location) {
      publicipProfile.location = options.location; } ;


    return publicipProfile; },


  _createDnsSettingsIfNotExist: function(publicip) {
    if (!publicip.dnsSettings) { publicip.dnsSettings = { }; }; }});



module.exports = PublicIp;
