/*** Generated by streamline 0.10.17 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; var __ = require("underscore");














var util = require("util");
var utils = require("../../../util/utils");
var $ = utils.getLocaleString;
var constants = require("./constants");
var resourceUtils = require("../resource/resourceUtils");
var lbShowUtil = require("./lbShowUtil");
var tagUtils = require("../tag/tagUtils");
var EndPointUtil = require("../../../util/endpointUtil");
var PublicIp = require("./publicIp");
var Subnet = require("./subnet");

function LoadBalancer(cli, networkResourceProviderClient) {
  this.networkResourceProviderClient = networkResourceProviderClient;
  this.publicIpCrud = new PublicIp(cli, networkResourceProviderClient);
  this.subnetCrud = new Subnet(cli, networkResourceProviderClient);
  this.endpointUtil = new EndPointUtil();
  this.output = cli.output;
  this.interaction = cli.interaction;};


__.extend(LoadBalancer.prototype, {
  create: function create__1(resourceGroupName, lbName, location, options, _) { var self, lb, lbProfile, progress, __this = this; var __frame = { name: "create__1", line: 37 }; return __func(_, this, arguments, create__1, 4, __frame, function __$create__1() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;
        if (lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" already exists in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        lbProfile = {
          location: location };


        if (options.tags) {
          lbProfile.tags = tagUtils.buildTagsParameter(null, options); } ;


        progress = self.interaction.progress(util.format($("Creating load balancer \"%s\""), lbName)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$create__1() {

              return self.networkResourceProviderClient.loadBalancers.createOrUpdate(resourceGroupName, lbName, lbProfile, __cb(_, __frame, 17, 55, function __$create__1() { _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$create__1() {

                progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$create__1() {

            return self.show(resourceGroupName, lbName, options, __cb(_, __frame, 21, 9, function __$create__1() { _(); }, true)); }); }); }, true)); }); },


  list: function list__2(resourceGroupName, _) { var self, progress, lbs, __this = this; var __frame = { name: "list__2", line: 61 }; return __func(_, this, arguments, list__2, 1, __frame, function __$list__2() { self = __this;

      progress = self.interaction.progress($("Getting the load balancers"));
      lbs = null; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$list__2() {

            return self.networkResourceProviderClient.loadBalancers.list(resourceGroupName, __cb(_, __frame, 5, 61, function ___(__0, __1) { lbs = __1; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$list__2() {

              progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$list__2() {


          self.interaction.formatOutput(lbs.loadBalancers, function(outputData) {
            if ((outputData.length === 0)) {
              self.output.warn($("No load balancers found")); }
             else {
              self.output.table(outputData, function(row, lb) {
                row.cell($("Name"), lb.name);
                row.cell($("Location"), lb.location);
                row.cell($("Probes"), lb.probes.length);
                row.cell($("Frontend IP"), lb.frontendIpConfigurations.length);
                row.cell($("Backend address pool"), lb.backendAddressPools.length);
                row.cell($("Load balancing rule"), lb.loadBalancingRules.length);
                row.cell($("Inbound NAT rule"), lb.inboundNatRules.length);
                row.cell($("Inbound NAT pool"), lb.inboundNatPools.length);
                row.cell($("Outnbound NAT rule"), lb.outboundNatRules.length); }); } ; }); _(); }); }); }); },





  show: function show__3(resourceGroupName, lbName, options, _) { var self, lb, __this = this; var __frame = { name: "show__3", line: 90 }; return __func(_, this, arguments, show__3, 3, __frame, function __$show__3() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        self.interaction.formatOutput(lb, function(lb) {
          if ((lb === null)) {
            self.output.warn(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName)); }
           else {
            lbShowUtil.show(lb, self.output); } ; }); _(); }, true)); }); },




  get: function get__4(resourceGroupName, lbName, _) { var self, progress, lb, __this = this; var __frame = { name: "get__4", line: 103 }; return __func(_, this, arguments, get__4, 2, __frame, function __$get__4() { self = __this;

      progress = self.interaction.progress(util.format($("Looking up the load balancer \"%s\""), lbName)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$get__4() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$get__4() {

                  return self.networkResourceProviderClient.loadBalancers.get(resourceGroupName, lbName, __cb(_, __frame, 4, 64, function ___(__0, __1) { lb = __1;
                    return _(null, lb.loadBalancer); }, true)); }); })(function ___(e, __result) { __catch(function __$get__4() { if (e) {

                    if ((e.statusCode === 404)) {
                      return _(null, null); } ;

                    return _(e); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$get__4() { _(null, null, true); }); }); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$get__4() {

              progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$get__4() { _(); }); }); }); },



  delete: function delete__5(resourceGroupName, lbName, options, _) { var self, lb, progress, __this = this; var __frame = { name: "delete__5", line: 119 }; return __func(_, this, arguments, delete__5, 3, __frame, function __$delete__5() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __2) { lb = __2;
        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ; return (function __$delete__5(_) {


          var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return self.interaction.confirm(util.format($("Delete load balancer \"%s\"? [y/n] "), lbName), __cb(_, __frame, 7, 44, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -118, 17, function ___(__0, __3) { return (function __$delete__5(__then) { if (__3) { return _(null); } else { __then(); } ; })(function __$delete__5() {



            progress = self.interaction.progress(util.format($("Deleting load balancer \"%s\""), lbName)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$delete__5() {

                  return self.networkResourceProviderClient.loadBalancers.deleteMethod(resourceGroupName, lbName, __cb(_, __frame, 13, 55, function __$delete__5() { _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$delete__5() {

                    progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$delete__5() { _(); }); }); }); }, true)); }, true)); }); },



  update: function update__6(resourceGroupName, lbName, parameters, _) { var self, progress, __this = this; var __frame = { name: "update__6", line: 138 }; return __func(_, this, arguments, update__6, 3, __frame, function __$update__6() { self = __this;

      progress = self.interaction.progress(util.format($("Updating load balancer \"%s\""), lbName)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$update__6() {

            return self.networkResourceProviderClient.loadBalancers.createOrUpdate(resourceGroupName, lbName, parameters, __cb(_, __frame, 4, 55, function __$update__6() { _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$update__6() {

              progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$update__6() { _(); }); }); }); },







  createProbe: function createProbe__7(resourceGroupName, lbName, probeName, options, _) { var self, probeProfile, lb, probe, __this = this; var __frame = { name: "createProbe__7", line: 152 }; return __func(_, this, arguments, createProbe__7, 4, __frame, function __$createProbe__7() { self = __this;

      probeProfile = self._parseProbe(probeName, options, true);
      return self.get(resourceGroupName, lbName, __cb(_, __frame, 3, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        probe = utils.findFirstCaseIgnore(lb.probes, { name: probeName });
        if (probe) {
          return _(new Error(util.format($("A probe with name \"%s\" already exists"), probeName))); } ;


        lb.probes.push(probeProfile);
        return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 15, 9, function __$createProbe__7() { _(); }, true)); }, true)); }); },


  setProbe: function setProbe__8(resourceGroupName, lbName, probeName, options, _) { var self, probeProfile, lb, probe, __this = this; var __frame = { name: "setProbe__8", line: 170 }; return __func(_, this, arguments, setProbe__8, 4, __frame, function __$setProbe__8() { self = __this;

      probeProfile = self._parseProbe(probeName, options, false);
      return self.get(resourceGroupName, lbName, __cb(_, __frame, 3, 18, function ___(__0, __1) { lb = __1;
        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        probe = utils.findFirstCaseIgnore(lb.probes, {
          name: probeName });

        if (!probe) {
          return _(new Error(util.format($("A probe with name \"%s\" not found"), probeName))); } ;


        if (options.newProbeName) { probe.name = probeProfile.name; } ;
        if (options.port) { probe.port = probeProfile.port; } ;
        if (options.path) { probe.requestPath = probeProfile.requestPath; } ;
        if (options.interval) { probe.intervalInSeconds = probeProfile.intervalInSeconds; } ;
        if (options.count) { probe.numberOfProbes = probeProfile.numberOfProbes; } ;
        if (options.protocol) {
          probe.protocol = probeProfile.protocol;
          if ((options.protocol.toLowerCase() === self.endpointUtil.protocols.TCP)) {
            delete probe.requestPath; } ; } ;


        return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 26, 9, function __$setProbe__8() { _(); }, true)); }, true)); }); },


  listProbes: function listProbes__9(resourceGroupName, lbName, options, _) { var self, lb, __this = this; var __frame = { name: "listProbes__9", line: 199 }; return __func(_, this, arguments, listProbes__9, 3, __frame, function __$listProbes__9() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;
        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        self.interaction.formatOutput(lb.probes, function(probes) {
          if ((probes.length === 0)) {
            self.output.warn($("No probes found")); }
           else {
            self.output.table(probes, function(row, probe) {
              row.cell($("Name"), probe.name);
              row.cell($("Provisioning state"), probe.provisioningState);
              row.cell($("Protocol"), probe.protocol);
              row.cell($("Port"), probe.port);
              row.cell($("Path"), (probe.requestPath || ""));
              row.cell($("Interval"), probe.intervalInSeconds);
              row.cell($("Count"), probe.numberOfProbes); }); } ; }); _(); }, true)); }); },





  deleteProbe: function deleteProbe__10(resourceGroupName, lbName, probeName, options, _) { var self, lb, probeIndex, __this = this; var __frame = { name: "deleteProbe__10", line: 223 }; return __func(_, this, arguments, deleteProbe__10, 4, __frame, function __$deleteProbe__10() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __2) { lb = __2;
        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        probeIndex = utils.indexOfCaseIgnore(lb.probes, { name: probeName });
        if ((probeIndex === -1)) {
          return _(new Error(util.format($("A probe with name with name \"%s\" not found in the load balancer \"%s\""), probeName, lbName))); } ; return (function __$deleteProbe__10(_) {


          var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return self.interaction.confirm(util.format($("Delete probe %s? [y/n] "), probeName), __cb(_, __frame, 12, 44, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -222, 17, function ___(__0, __3) { return (function __$deleteProbe__10(__then) { if (__3) { return _(null); } else { __then(); } ; })(function __$deleteProbe__10() {



            lb.probes.splice(probeIndex, 1);
            return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 17, 9, function __$deleteProbe__10() { _(); }, true)); }); }, true)); }, true)); }); },






  createFrontendIP: function createFrontendIP__11(resourceGroupName, lbName, fipName, options, _) { var self, lb, fipConfiguration, updatedLb, updatedFip, __this = this; var __frame = { name: "createFrontendIP__11", line: 247 }; return __func(_, this, arguments, createFrontendIP__11, 4, __frame, function __$createFrontendIP__11() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        fipConfiguration = {
          name: fipName };

        return self._parseFrontendIP(resourceGroupName, fipConfiguration, options, __cb(_, __frame, 11, 28, function ___(__0, __2) { fipConfiguration = __2;

          if (utils.findFirstCaseIgnore(lb.frontendIpConfigurations, { name: fipName })) {
            return _(new Error(util.format($("Frontend IP configuration with name \"%s\" already exists in the load balancer \"%s\""), fipName, lbName))); } ;


          lb.frontendIpConfigurations.push(fipConfiguration);
          return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 18, 9, function __$createFrontendIP__11() {

            return self.get(resourceGroupName, lbName, __cb(_, __frame, 20, 25, function ___(__0, __3) { updatedLb = __3;
              updatedFip = utils.findFirstCaseIgnore(updatedLb.frontendIpConfigurations, { name: fipName });
              self.showFrontendIP(updatedFip); _(); }, true)); }, true)); }, true)); }, true)); }); },


  setFrontendIP: function setFrontendIP__12(resourceGroupName, lbName, fipName, options, _) { var self, lb, fipConfiguration, updatedLb, updatedFip, __this = this; var __frame = { name: "setFrontendIP__12", line: 272 }; return __func(_, this, arguments, setFrontendIP__12, 4, __frame, function __$setFrontendIP__12() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        fipConfiguration = utils.findFirstCaseIgnore(lb.frontendIpConfigurations, { name: fipName });
        if (!fipConfiguration) {
          return _(new Error(util.format($("Frontend IP configuration with name \"%s\" not found in the load balancer \"%s\""), ruleName, lbName))); } ;


        return self._parseFrontendIP(resourceGroupName, fipConfiguration, options, __cb(_, __frame, 13, 9, function __$setFrontendIP__12() {
          return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 14, 9, function __$setFrontendIP__12() {

            return self.get(resourceGroupName, lbName, __cb(_, __frame, 16, 25, function ___(__0, __2) { updatedLb = __2;
              updatedFip = utils.findFirstCaseIgnore(updatedLb.frontendIpConfigurations, { name: fipName });
              self.showFrontendIP(updatedFip); _(); }, true)); }, true)); }, true)); }, true)); }); },


  listFrontendIPs: function listFrontendIPs__13(resourceGroupName, lbName, options, _) { var self, lb, __this = this; var __frame = { name: "listFrontendIPs__13", line: 293 }; return __func(_, this, arguments, listFrontendIPs__13, 3, __frame, function __$listFrontendIPs__13() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        self.interaction.formatOutput(lb.frontendIpConfigurations, function(frontendIpConfigurations) {
          if ((frontendIpConfigurations.length === 0)) {
            self.output.warn($("No frontend ip configurations found")); }
           else {
            self.output.table(frontendIpConfigurations, function(row, fip) {
              row.cell($("Name"), fip.name);
              row.cell($("Provisioning state"), fip.provisioningState);
              row.cell($("Private IP allocation method"), fip.privateIpAllocationMethod);
              row.cell($("Subnet"), (fip.subnet ? fip.subnet.id : "")); }); } ; }); _(); }, true)); }); },





  showFrontendIP: function(fipConfig) {
    var self = this;
    self.interaction.formatOutput(fipConfig, function(fipConfig) {
      lbShowUtil.showFrontendIpConfig(fipConfig, self.output); }); },



  deleteFrontendIP: function deleteFrontendIP__14(resourceGroupName, lbName, fipName, options, _) { var self, lb, fipIndex, __this = this; var __frame = { name: "deleteFrontendIP__14", line: 322 }; return __func(_, this, arguments, deleteFrontendIP__14, 4, __frame, function __$deleteFrontendIP__14() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __2) { lb = __2;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        fipIndex = utils.indexOfCaseIgnore(lb.frontendIpConfigurations, { name: fipName });
        if ((fipIndex === -1)) {
          return _(new Error(util.format($("Frontend ip configuration with name \"%s\" not found in the load balancer \"%s\""), fipName, lbName))); } ; return (function __$deleteFrontendIP__14(_) {


          var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return self.interaction.confirm(util.format($("Delete frontend ip configuration %s? [y/n] "), fipName), __cb(_, __frame, 13, 44, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -321, 17, function ___(__0, __3) { return (function __$deleteFrontendIP__14(__then) { if (__3) { return _(null); } else { __then(); } ; })(function __$deleteFrontendIP__14() {



            lb.frontendIpConfigurations.splice(fipIndex, 1);
            return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 18, 9, function __$deleteFrontendIP__14() { _(); }, true)); }); }, true)); }, true)); }); },






  createBackendAddressPool: function createBackendAddressPool__15(resourceGroupName, lbName, poolName, options, _) { var self, lb, backendAddressPool, updatedLb, updatedPool, __this = this; var __frame = { name: "createBackendAddressPool__15", line: 347 }; return __func(_, this, arguments, createBackendAddressPool__15, 4, __frame, function __$createBackendAddressPool__15() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        if (utils.findFirstCaseIgnore(lb.backendAddressPools, { name: poolName })) {
          return _(new Error(util.format($("A backend address pool with name \"%s\" already exists in the load balancer \"%s\""), ruleName, lbName))); } ;


        backendAddressPool = {
          name: poolName,
          properties: { } };


        lb.backendAddressPools.push(backendAddressPool);
        return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 18, 9, function __$createBackendAddressPool__15() {

          return self.get(resourceGroupName, lbName, __cb(_, __frame, 20, 25, function ___(__0, __2) { updatedLb = __2;
            updatedPool = utils.findFirstCaseIgnore(updatedLb.backendAddressPools, { name: poolName });
            self.showBackendAddressPool(updatedPool); _(); }, true)); }, true)); }, true)); }); },


  listBackendAddressPools: function listBackendAddressPools__16(resourceGroupName, lbName, options, _) { var self, lb, __this = this; var __frame = { name: "listBackendAddressPools__16", line: 372 }; return __func(_, this, arguments, listBackendAddressPools__16, 3, __frame, function __$listBackendAddressPools__16() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        self.interaction.formatOutput(lb.backendAddressPools, function(backendAddressPools) {
          if ((backendAddressPools.length === 0)) {
            self.output.warn($("No backend address pools found")); }
           else {
            self.output.table(backendAddressPools, function(row, pool) {
              row.cell($("Name"), pool.name);
              row.cell($("Provisioning state"), pool.provisioningState); }); } ; }); _(); }, true)); }); },





  showBackendAddressPool: function(backendAddressPool) {
    var self = this;
    self.interaction.formatOutput(backendAddressPool, function(backendAddressPool) {
      lbShowUtil.showBackendAddressPool(backendAddressPool, self.output); }); },



  deleteBackendAddressPool: function deleteBackendAddressPool__17(resourceGroupName, lbName, poolName, options, _) { var self, lb, poolIndex, __this = this; var __frame = { name: "deleteBackendAddressPool__17", line: 399 }; return __func(_, this, arguments, deleteBackendAddressPool__17, 4, __frame, function __$deleteBackendAddressPool__17() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __2) { lb = __2;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        poolIndex = utils.indexOfCaseIgnore(lb.backendAddressPools, { name: poolName });
        if ((poolIndex === -1)) {
          return _(new Error(util.format($("Backend address pool with name with name \"%s\" not found in the load balancer \"%s\""), poolName, lbName))); } ; return (function __$deleteBackendAddressPool__17(_) {


          var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return self.interaction.confirm(util.format($("Delete backend address pool %s? [y/n] "), poolName), __cb(_, __frame, 13, 44, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -398, 17, function ___(__0, __3) { return (function __$deleteBackendAddressPool__17(__then) { if (__3) { return _(null); } else { __then(); } ; })(function __$deleteBackendAddressPool__17() {



            lb.backendAddressPools.splice(poolIndex, 1);
            return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 18, 9, function __$deleteBackendAddressPool__17() { _(); }, true)); }); }, true)); }, true)); }); },






  createRule: function createRule__18(resourceGroupName, lbName, ruleName, options, _) { var self, lb, lbRule, rule, updatedLb, updatedRule, __this = this; var __frame = { name: "createRule__18", line: 424 }; return __func(_, this, arguments, createRule__18, 4, __frame, function __$createRule__18() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;
        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        lbRule = utils.findFirstCaseIgnore(lb.loadBalancingRules, { name: ruleName });
        if (lbRule) {
          return _(new Error(util.format($("Load balancing rule with name \"%s\" already exists in load balancer \"%s\""), ruleName, lbName))); } ;


        rule = {
          name: ruleName };

        rule = self._parseRule(lb, rule, options, true);

        lb.loadBalancingRules.push(rule);
        return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 18, 9, function __$createRule__18() {

          return self.get(resourceGroupName, lbName, __cb(_, __frame, 20, 25, function ___(__0, __2) { updatedLb = __2;
            updatedRule = utils.findFirstCaseIgnore(updatedLb.loadBalancingRules, { name: ruleName });
            self.showRule(updatedRule); _(); }, true)); }, true)); }, true)); }); },


  setRule: function setRule__19(resourceGroupName, lbName, ruleName, options, _) { var self, lb, lbRule, updatedLb, updatedRule, __this = this; var __frame = { name: "setRule__19", line: 449 }; return __func(_, this, arguments, setRule__19, 4, __frame, function __$setRule__19() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        lbRule = utils.findFirstCaseIgnore(lb.loadBalancingRules, { name: ruleName });
        if (!lbRule) {
          return _(new Error(util.format($("Rule with the name \"%s\" not found in load balancer \"%s\""), ruleName, lbName))); } ;


        lbRule.name = (options.newRuleName || ruleName);
        lbRule = self._parseRule(lb, lbRule, options, false);
        return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 15, 9, function __$setRule__19() {

          return self.get(resourceGroupName, lbName, __cb(_, __frame, 17, 25, function ___(__0, __2) { updatedLb = __2;
            updatedRule = utils.findFirstCaseIgnore(updatedLb.loadBalancingRules, { name: ruleName });
            self.showRule(updatedRule); _(); }, true)); }, true)); }, true)); }); },


  listRules: function listRules__20(resourceGroupName, lbName, options, _) { var self, lb, __this = this; var __frame = { name: "listRules__20", line: 471 }; return __func(_, this, arguments, listRules__20, 3, __frame, function __$listRules__20() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        self.interaction.formatOutput(lb.loadBalancingRules, function(loadBalancingRules) {
          if ((loadBalancingRules.length === 0)) {
            self.output.warn($("No load balancing rules found")); }
           else {
            self.output.table(loadBalancingRules, function(row, rule) {
              row.cell($("Name"), rule.name);
              row.cell($("Provisioning state"), rule.provisioningState);
              row.cell($("Load distribution"), rule.loadDistribution);
              row.cell($("Protocol"), rule.protocol);
              row.cell($("Frontend port"), rule.frontendPort);
              row.cell($("Backend port"), rule.backendPort);
              row.cell($("Enable floating IP"), rule.enableFloatingIP);
              row.cell($("Idle timeout in minutes"), rule.idleTimeoutInMinutes); }); } ; }); _(); }, true)); }); },





  showRule: function(rule) {
    var self = this;
    self.interaction.formatOutput(rule, function(rule) {
      lbShowUtil.showLBRule(rule, self.output); }); },



  deleteRule: function deleteRule__21(resourceGroupName, lbName, ruleName, options, _) { var self, lb, ruleIndex, __this = this; var __frame = { name: "deleteRule__21", line: 504 }; return __func(_, this, arguments, deleteRule__21, 4, __frame, function __$deleteRule__21() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __2) { lb = __2;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        ruleIndex = utils.indexOfCaseIgnore(lb.loadBalancingRules, { name: ruleName });
        if ((ruleIndex === -1)) {
          return _(new Error(util.format($("A load balancing rule with name \"%s\" not found in the load balancer \"%s\""), ruleName, lbName))); } ; return (function __$deleteRule__21(_) {


          var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return self.interaction.confirm(util.format($("Delete load balancing rule %s? [y/n] "), ruleName), __cb(_, __frame, 13, 44, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -503, 17, function ___(__0, __3) { return (function __$deleteRule__21(__then) { if (__3) { return _(null); } else { __then(); } ; })(function __$deleteRule__21() {



            lb.loadBalancingRules.splice(ruleIndex, 1);
            return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 18, 9, function __$deleteRule__21() { _(); }, true)); }); }, true)); }, true)); }); },






  createInboundNatRule: function createInboundNatRule__22(resourceGroupName, lbName, ruleName, options, _) { var self, lb, inboundRule, updatedLb, updatedRule, __this = this; var __frame = { name: "createInboundNatRule__22", line: 529 }; return __func(_, this, arguments, createInboundNatRule__22, 4, __frame, function __$createInboundNatRule__22() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        inboundRule = {
          name: ruleName };

        inboundRule = self._parseInboundNatRule(resourceGroupName, lb, inboundRule, options, true);

        if (utils.findFirstCaseIgnore(lb.inboundNatRules, { name: ruleName })) {
          return _(new Error(util.format($("An inbound NAT rule with name \"%s\" already exists in the load balancer \"%s\""), ruleName, lbName))); } ;


        lb.inboundNatRules.push(inboundRule);
        return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 18, 9, function __$createInboundNatRule__22() {

          return self.get(resourceGroupName, lbName, __cb(_, __frame, 20, 25, function ___(__0, __2) { updatedLb = __2;
            updatedRule = utils.findFirstCaseIgnore(updatedLb.inboundNatRules, { name: ruleName });
            self.showInboundNatRule(updatedRule); _(); }, true)); }, true)); }, true)); }); },


  setInboundNatRule: function setInboundNatRule__23(resourceGroupName, lbName, ruleName, options, _) { var self, lb, inboundRule, updatedLb, updatedRule, __this = this; var __frame = { name: "setInboundNatRule__23", line: 554 }; return __func(_, this, arguments, setInboundNatRule__23, 4, __frame, function __$setInboundNatRule__23() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        inboundRule = utils.findFirstCaseIgnore(lb.inboundNatRules, { name: ruleName });
        if (!inboundRule) {
          return _(new Error(util.format($("An inbound NAT rule with name \"%s\" not found in the load balancer \"%s\""), ruleName, lbName))); } ;


        self._parseInboundNatRule(resourceGroupName, lb, inboundRule, options, false);
        return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 14, 9, function __$setInboundNatRule__23() {

          return self.get(resourceGroupName, lbName, __cb(_, __frame, 16, 25, function ___(__0, __2) { updatedLb = __2;
            updatedRule = utils.findFirstCaseIgnore(updatedLb.inboundNatRules, { name: ruleName });
            self.showInboundNatRule(updatedRule); _(); }, true)); }, true)); }, true)); }); },


  listInboundNatRules: function listInboundNatRules__24(resourceGroupName, lbName, options, _) { var self, lb, __this = this; var __frame = { name: "listInboundNatRules__24", line: 575 }; return __func(_, this, arguments, listInboundNatRules__24, 3, __frame, function __$listInboundNatRules__24() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        self.interaction.formatOutput(lb.inboundNatRules, function(inboundNatRules) {
          if ((inboundNatRules.length === 0)) {
            self.output.warn($("No inbound NAT rules found")); }
           else {
            self.output.table(inboundNatRules, function(row, rule) {
              row.cell($("Name"), rule.name);
              row.cell($("Provisioning state"), rule.provisioningState);
              row.cell($("Protocol"), rule.protocol);
              row.cell($("Frontend port"), rule.frontendPort);
              row.cell($("Backend port"), rule.backendPort);
              row.cell($("Enable floating IP"), rule.enableFloatingIP);
              row.cell($("Idle timeout in minutes"), rule.idleTimeoutInMinutes); }); } ; }); _(); }, true)); }); },





  showInboundNatRule: function(rule) {
    var self = this;
    self.interaction.formatOutput(rule, function(rule) {
      lbShowUtil.showInboundRule(rule, self.output); }); },



  deleteInboundNatRule: function deleteInboundNatRule__25(resourceGroupName, lbName, ruleName, options, _) { var self, lb, ruleIndex, __this = this; var __frame = { name: "deleteInboundNatRule__25", line: 607 }; return __func(_, this, arguments, deleteInboundNatRule__25, 4, __frame, function __$deleteInboundNatRule__25() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __2) { lb = __2;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        ruleIndex = utils.indexOfCaseIgnore(lb.inboundNatRules, { name: ruleName });
        if ((ruleIndex === -1)) {
          return _(new Error(util.format($("An inbound NAT rule with name \"%s\" not found in the load balancer \"%s\""), ruleName, lbName))); } ; return (function __$deleteInboundNatRule__25(_) {


          var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return self.interaction.confirm(util.format($("Delete inbound NAT rule %s? [y/n] "), ruleName), __cb(_, __frame, 13, 44, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -606, 17, function ___(__0, __3) { return (function __$deleteInboundNatRule__25(__then) { if (__3) { return _(null); } else { __then(); } ; })(function __$deleteInboundNatRule__25() {



            lb.inboundNatRules.splice(ruleIndex, 1);
            return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 18, 9, function __$deleteInboundNatRule__25() { _(); }, true)); }); }, true)); }, true)); }); },






  createInboundNatPool: function createInboundNatPool__26(resourceGroupName, lbName, poolName, options, _) { var self, lb, inboundPool, updatedLb, updatedPool, __this = this; var __frame = { name: "createInboundNatPool__26", line: 632 }; return __func(_, this, arguments, createInboundNatPool__26, 4, __frame, function __$createInboundNatPool__26() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;
        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        inboundPool = {
          name: poolName };

        inboundPool = self._parseInboundNatPool(resourceGroupName, lb, inboundPool, options, true);

        if (utils.findFirstCaseIgnore(lb.inboundNatPools, { name: poolName })) {
          return _(new Error(util.format($("An inbound NAT pool with name \"%s\" already exists in the load balancer \"%s\""), poolName, lbName))); } ;


        lb.inboundNatPools.push(inboundPool);
        return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 17, 9, function __$createInboundNatPool__26() {

          return self.get(resourceGroupName, lbName, __cb(_, __frame, 19, 25, function ___(__0, __2) { updatedLb = __2;
            updatedPool = utils.findFirstCaseIgnore(updatedLb.inboundNatPools, { name: poolName });
            if (!updatedPool) { return _(new Error(util.format($("An inbound NAT pool with name \"%s\" not found in the resource group \"%s\""), poolName, resourceGroupName))); } ;

            self.showInboundNatPool(updatedPool); _(); }, true)); }, true)); }, true)); }); },


  setInboundNatPool: function setInboundNatPool__27(resourceGroupName, lbName, poolName, options, _) { var self, lb, inboundPool, updatedLb, updatedPool, __this = this; var __frame = { name: "setInboundNatPool__27", line: 658 }; return __func(_, this, arguments, setInboundNatPool__27, 4, __frame, function __$setInboundNatPool__27() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;
        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        inboundPool = utils.findFirstCaseIgnore(lb.inboundNatPools, { name: poolName });
        if (!inboundPool) {
          return _(new Error(util.format($("An inbound NAT pool with name \"%s\" not found in the load balancer \"%s\""), poolName, lbName))); } ;


        self._parseInboundNatPool(resourceGroupName, lb, inboundPool, options, false);
        return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 13, 9, function __$setInboundNatPool__27() {

          return self.get(resourceGroupName, lbName, __cb(_, __frame, 15, 25, function ___(__0, __2) { updatedLb = __2;
            updatedPool = utils.findFirstCaseIgnore(updatedLb.inboundNatPools, { name: poolName });
            self.showInboundNatPool(updatedPool); _(); }, true)); }, true)); }, true)); }); },


  listInboundNatPools: function listInboundNatPools__28(resourceGroupName, lbName, options, _) { var self, lb, __this = this; var __frame = { name: "listInboundNatPools__28", line: 678 }; return __func(_, this, arguments, listInboundNatPools__28, 3, __frame, function __$listInboundNatPools__28() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __1) { lb = __1;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        self.interaction.formatOutput(lb.inboundNatPools, function(inboundPools) {
          if ((inboundPools.length === 0)) {
            self.output.warn($("No inbound NAT pools found")); }
           else {
            self.output.table(inboundPools, function(row, pool) {
              row.cell($("Name"), pool.name);
              row.cell($("Provisioning state"), pool.provisioningState);
              row.cell($("Protocol"), pool.protocol);
              row.cell($("Port range start"), pool.frontendPortRangeStart);
              row.cell($("Port range end"), pool.frontendPortRangeEnd);
              row.cell($("Backend port"), pool.backendPort);
              var fipInfo = resourceUtils.getResourceInformation(pool.frontendIPConfiguration.id);
              row.cell($("Frontend IP configuration"), fipInfo.resourceName); }); } ; }); _(); }, true)); }); },





  showInboundNatPool: function(pool) {
    var self = this;
    self.interaction.formatOutput(pool, function(pool) {
      self.output.nameValue($("Name"), pool.name);
      self.output.nameValue($("Provisioning state"), pool.provisioningState);
      self.output.nameValue($("Protocol"), pool.protocol);
      self.output.nameValue($("Frontend port range start"), pool.frontendPortRangeStart);
      self.output.nameValue($("Frontend port range end"), pool.frontendPortRangeEnd);
      self.output.nameValue($("Backend port"), pool.backendPort);
      self.output.nameValue($("Frontend IP configuration"), pool.frontendIPConfiguration.id); }); },



  deleteInboundNatPool: function deleteInboundNatPool__29(resourceGroupName, lbName, poolName, options, _) { var self, lb, poolIndex, __this = this; var __frame = { name: "deleteInboundNatPool__29", line: 717 }; return __func(_, this, arguments, deleteInboundNatPool__29, 4, __frame, function __$deleteInboundNatPool__29() { self = __this;

      return self.get(resourceGroupName, lbName, __cb(_, __frame, 2, 18, function ___(__0, __2) { lb = __2;

        if (!lb) {
          return _(new Error(util.format($("A load balancer with name \"%s\" not found in the resource group \"%s\""), lbName, resourceGroupName))); } ;


        poolIndex = utils.indexOfCaseIgnore(lb.inboundNatPools, { name: poolName });
        if ((poolIndex === -1)) {
          return _(new Error(util.format($("An inbound NAT pool with name \"%s\" not found in the load balancer \"%s\""), poolName, lbName))); } ; return (function __$deleteInboundNatPool__29(_) {


          var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return self.interaction.confirm(util.format($("Delete inbound NAT pool %s? [y/n] "), poolName), __cb(_, __frame, 13, 44, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -716, 17, function ___(__0, __3) { return (function __$deleteInboundNatPool__29(__then) { if (__3) { return _(null); } else { __then(); } ; })(function __$deleteInboundNatPool__29() {



            lb.inboundNatPools.splice(poolIndex, 1);
            return self.update(resourceGroupName, lbName, lb, __cb(_, __frame, 18, 9, function __$deleteInboundNatPool__29() { _(); }, true)); }); }, true)); }, true)); }); },






  _parseProbe: function(probeName, params, useDefaults) {
    var self = this;

    var probeProfile = {
      name: probeName };


    if (params.path) {
      if (utils.stringIsNullOrEmpty(params.path)) {
        throw new Error($("Path parameter must not be null or empty string")); } ;

      probeProfile.requestPath = params.path; } ;


    if (params.protocol) {
      var protocolValidation = self.endpointUtil.validateProbProtocol(params.protocol, "Protocol");
      if (protocolValidation.error) {
        throw new Error(protocolValidation.error); } ;


      var protocol = protocolValidation.protocol.toLowerCase();
      if (((protocol === self.endpointUtil.protocols.TCP) && params.path)) {
        self.output.warn($("Probe request path will be ignored when its protocol is Tcp"));
        delete probeProfile.requestPath; } ;


      if (((protocol === self.endpointUtil.protocols.HTTP) && !params.path)) {
        throw new Error($("Probe request path is required when its protocol is Http")); } ;


      probeProfile.protocol = protocolValidation.protocol; }
     else if (useDefaults) {
      self.output.warn(util.format($("Using default probe protocol: %s"), constants.lb.defProtocol));
      probeProfile.protocol = constants.lb.defProtocol; }  ;


    if (params.port) {
      var portValidation = self.endpointUtil.validatePort(params.port, "Port");
      if (portValidation.error) { throw new Error(portValidation.error) };
      probeProfile.port = portValidation.port; }
     else if (useDefaults) {
      self.output.warn(util.format($("Using default probe port: %s"), constants.lb.defPort));
      probeProfile.port = constants.lb.defPort; }  ;


    if (params.interval) {
      var intervalValidation = self.endpointUtil.validateProbInterval(params.interval, "Interval");
      if (intervalValidation.error) { throw new Error(intervalValidation.error) };
      probeProfile.intervalInSeconds = intervalValidation.interval; } ;


    if (params.count) {
      var countAsInt = utils.parseInt(params.count);
      if (isNaN(countAsInt)) {
        throw new Error(util.format($("Count parameter must be an integer"), countAsInt)); } ;

      probeProfile.numberOfProbes = countAsInt; } ;


    if (params.newProbeName) {
      if (utils.stringIsNullOrEmpty(params.newProbeName)) {
        throw new Error($("Name parameter must not be null or empty string")); } ;

      probeProfile.name = params.newProbeName; } ;


    return probeProfile; },


  _parseRule: function(lb, rule, options, useDefaults) {
    var self = this;

    if (options.protocol) {
      var protocolValidation = self.endpointUtil.validateProtocol(options.protocol, "protocol");
      if (protocolValidation.error) {
        throw new Error(protocolValidation.error); } ;


      rule.protocol = options.protocol; }
     else if (useDefaults) {
      options.protocol = constants.lb.defProtocol;
      self.output.warn(util.format($("Using default protocol: %s"), options.protocol));
      rule.protocol = options.protocol; }  ;


    if (options.frontendPort) {
      var frontendPortValidation = self.endpointUtil.validatePort(options.frontendPort, "front end port");
      if (frontendPortValidation.error) {
        throw new Error(frontendPortValidation.error); } ;


      rule.frontendPort = options.frontendPort; }
     else if (useDefaults) {
      options.frontendPort = constants.lb.defPort;
      self.output.warn(util.format($("Using default frontend port: %s"), options.frontendPort));
      rule.frontendPort = options.frontendPort; }  ;


    if (options.backendPort) {
      var backendPortValidation = self.endpointUtil.validatePort(options.backendPort, "back end port");
      if (backendPortValidation.error) {
        throw new Error(backendPortValidation.error); } ;


      rule.backendPort = options.backendPort; }
     else if (useDefaults) {
      options.backendPort = constants.lb.defPort;
      self.output.warn(util.format($("Using default backend port: %s"), options.backendPort));
      rule.backendPort = options.backendPort; }  ;


    if (options.idleTimeout) {
      var parsed = utils.parseInt(options.idleTimeout);
      if (isNaN(parsed)) {
        throw new Error($("Idle timeout must be posivite integer")); } ;


      rule.idleTimeoutInMinutes = options.idleTimeout; }
     else if (useDefaults) {
      options.idleTimeout = constants.lb.defTimeout;
      self.output.warn(util.format($("Using default idle timeout: %s"), options.idleTimeout));
      rule.idleTimeoutInMinutes = options.idleTimeout; }  ;


    if (options.enableFloatingIp) {


      if ((!utils.ignoreCaseEquals(options.enableFloatingIp, "true") && !utils.ignoreCaseEquals(options.enableFloatingIp, "false"))) {
        throw new Error($("Enable floating IP parameter must be boolean")); } ;


      rule.enableFloatingIP = options.enableFloatingIp; }
     else if (useDefaults) {
      options.enableFloatingIp = constants.lb.defFloatingIp;
      self.output.warn(util.format($("Using default enable floating ip: %s"), options.enableFloatingIp));
      rule.enableFloatingIP = options.enableFloatingIp; }  ;


    var backendAddressPool = null;
    if (options.backendAddressPool) {
      backendAddressPool = utils.findFirstCaseIgnore(lb.backendAddressPools, {
        name: options.backendAddressPool });

      if (!backendAddressPool) {
        throw new Error(util.format($("Backend address pool \"%s\" not found"), options.backendAddressPool)); } ;


      rule.backendAddressPool = {
        id: backendAddressPool.id }; }

     else if (useDefaults) {
      if ((!lb.backendAddressPools || (lb.backendAddressPools.length === 0))) {
        throw new Error($("Load balancer must have at least one backend address pool if --backend-address-pool parameter is not specified.")); } ;


      self.output.warn(util.format($("Using first backend address pool: %s"), lb.backendAddressPools[0].name));
      backendAddressPool = lb.backendAddressPools[0];
      rule.backendAddressPool = {
        id: backendAddressPool.id }; }  ;



    if (options.frontendIpName) {
      rule.frontendIPConfiguration = { };
      ipConfigFound = utils.findFirstCaseIgnore(lb.frontendIpConfigurations, {
        name: options.frontendIpName });

      if (!ipConfigFound) {
        throw new Error(util.format($("Frontend IP config \"%s\" not found"), options.frontendIpName)); } ;


      rule.frontendIPConfiguration.id = ipConfigFound.id; }
     else if (useDefaults) {
      rule.frontendIPConfiguration = { };
      if ((!lb.frontendIpConfigurations || (lb.frontendIpConfigurations.length === 0))) {
        throw new Error($("Load balancer must have at least one frontend IP configuration if --frontend-ip-name parameter is not specified.")); } ;


      self.output.warn(util.format($("Using first frontend IP config: %s"), lb.frontendIpConfigurations[0].name));
      defaultIpConfig = lb.frontendIpConfigurations[0];
      rule.frontendIPConfiguration.id = defaultIpConfig.id; }  ;


    var optionalProbe = utils.getOptionalArg(options.probeName);
    if (optionalProbe.hasValue) {
      if ((optionalProbe.value !== null)) {

        if ((!lb.probes || (lb.probes.length === 0))) {
          throw new Error(util.format($("No probes found for the load balancer \"%s\""), lb.name)); } ;



        var probe = utils.findFirstCaseIgnore(lb.probes, {
          name: options.probeName });

        if (!probe) {
          throw new Error(util.format($("Probe \"%s\" not found in the load balancer \"%s\""), options.probeName, lb.name)); } ;


        rule.probe = {
          id: probe.id }; }

       else {
        self.output.warn($("Clearing probe"));
        if (rule.probe) {
          delete rule.probe; } ; } ; } ;




    return rule; },


  _parseInboundNatRule: function(resourceGroupName, lb, inboundRule, options, useDefaults) {
    var self = this;

    if (options.protocol) {
      var protocolValidation = self.endpointUtil.validateProtocol(options.protocol, "protocol");
      if (protocolValidation.error) {
        throw new Error(protocolValidation.error); } ;

      inboundRule.protocol = options.protocol; }
     else if (useDefaults) {
      options.protocol = constants.lb.defProtocol;
      self.output.warn(util.format($("Using default protocol: %s"), options.protocol));
      inboundRule.protocol = options.protocol; }  ;


    if (options.frontendPort) {
      var frontendPortValidation = self.endpointUtil.validatePort(options.frontendPort, "front end port");
      if (frontendPortValidation.error) {
        throw new Error(frontendPortValidation.error); } ;

      inboundRule.frontendPort = options.frontendPort; }
     else if (useDefaults) {
      options.frontendPort = constants.lb.defPort;
      self.output.warn(util.format($("Using default frontend port: %s"), options.frontendPort));
      inboundRule.frontendPort = options.frontendPort; }  ;


    if (options.backendPort) {
      var backendPortValidation = self.endpointUtil.validatePort(options.backendPort, "back end port");
      if (backendPortValidation.error) {
        throw new Error(backendPortValidation.error); } ;

      inboundRule.backendPort = options.backendPort; }
     else if (useDefaults) {
      options.backendPort = constants.lb.defPort;
      self.output.warn(util.format($("Using default backend port: %s"), options.backendPort));
      inboundRule.backendPort = options.backendPort; }  ;


    if (options.enableFloatingIp) {


      if ((!utils.ignoreCaseEquals(options.enableFloatingIp, "true") && !utils.ignoreCaseEquals(options.enableFloatingIp, "false"))) {
        throw new Error($("Enable floating IP parameter must be boolean")); } ;


      inboundRule.enableFloatingIP = options.enableFloatingIp; }
     else if (useDefaults) {
      self.output.warn(util.format($("Using default enable floating ip: %s"), constants.lb.defFloatingIp));
      inboundRule.enableFloatingIP = constants.lb.defFloatingIp; }  ;


    if (options.frontendIp) {
      var ipConfigurations = options.frontendIp.split(",");
      for (var num in ipConfigurations) {
        var frontendIpConf = ipConfigurations[num];
        var frontendIpConfFound = utils.findFirstCaseIgnore(lb.frontendIpConfigurations, {
          name: frontendIpConf });

        if (!frontendIpConfFound) {
          throw new Error(util.format($("Frontend IP config \"%s\" not found"), frontendIpConf)); } ;

        inboundRule.frontendIPConfiguration = {
          id: frontendIpConfFound.id }; }; }


     else if (useDefaults) {
      if (!inboundRule.frontendIPConfiguration) {
        if ((lb.frontendIpConfigurations.length === 0)) {
          throw new Error(util.format($("Load balancer with name \"%s\" has no frontend IP configurations"), lb.name)); } ;

        inboundRule.frontendIPConfiguration = {
          id: lb.frontendIpConfigurations[0].id };

        self.output.warn($("Setting default inbound rule frontend IP configuration")); } ; }  ;



    return inboundRule; },


  _parseInboundNatPool: function(resourceGroupName, lb, inboundPool, options, useDefaults) {
    var self = this;

    if (options.protocol) {
      utils.verifyParamExistsInCollection(constants.lb.protocols, options.protocol, "--protocol");
      inboundPool.protocol = options.protocol; }
     else if (useDefaults) {
      var defProtocol = constants.lb.protocols[0];
      self.output.warn(util.format($("Using default protocol: %s"), defProtocol));
      inboundPool.protocol = defProtocol; }  ;


    if (options.frontendPortRangeStart) {
      var portStartValidation = self.endpointUtil.validatePort(options.frontendPortRangeStart, "--frontend-port-range-start");
      if (portStartValidation.error) {
        throw new Error(portStartValidation.error); } ;

      inboundPool.frontendPortRangeStart = options.frontendPortRangeStart; }
     else if (useDefaults) {
      var defPortRangeStart = constants.portBounds[0];
      self.output.warn(util.format($("Using default frontend port range start: %s"), defPortRangeStart));
      inboundPool.frontendPortRangeStart = defPortRangeStart; }  ;


    if (options.frontendPortRangeEnd) {
      var portEndValidation = self.endpointUtil.validatePort(options.frontendPortRangeEnd, "--frontend-port-range-end");
      if (portEndValidation.error) {
        throw new Error(portEndValidation.error); } ;

      inboundPool.frontendPortRangeEnd = options.frontendPortRangeEnd; }
     else if (useDefaults) {
      var defPortRangeEnd = constants.portBounds[1];
      self.output.warn(util.format($("Using default frontend port range end: %s"), defPortRangeEnd));
      inboundPool.frontendPortRangeEnd = defPortRangeEnd; }  ;


    if ((options.frontendPortRangeStart && options.frontendPortRangeEnd)) {
      if ((options.frontendPortRangeStart > options.frontendPortRangeEnd)) {
        throw new Error($("The frontend port range start should be less or equal to frontend port range end")); } ; } ;



    if (options.backendPort) {
      var backendPortValidation = self.endpointUtil.validatePort(options.backendPort, "--backend-port");
      if (backendPortValidation.error) {
        throw new Error(backendPortValidation.error); } ;

      inboundPool.backendPort = options.backendPort; }
     else if (useDefaults) {
      self.output.warn(util.format($("Using default backend port: %s"), constants.lb.defPort));
      inboundPool.backendPort = constants.lb.defPort; }  ;


    if (options.frontendIp) {
      var frontendIpConfig = utils.findFirstCaseIgnore(lb.frontendIpConfigurations, { name: options.frontendIp });
      if (!frontendIpConfig) {
        throw new Error(util.format($("Frontend IP configuration with name \"%s\" not found in load balancer \"%s\""), options.frontendIp, lb.name)); } ;

      inboundPool.frontendIPConfiguration = {
        id: frontendIpConfig.id }; }

     else if (useDefaults) {
      if (!inboundPool.frontendIPConfiguration) {
        if ((lb.frontendIpConfigurations.length === 0)) {
          throw new Error(util.format($("Load balancer with name \"%s\" has no frontend IP configurations"), lb.name)); } ;

        inboundPool.frontendIPConfiguration = {
          id: lb.frontendIpConfigurations[0].id };

        self.output.warn($("Setting default inbound NAT pool frontend IP configuration")); } ; }  ;



    return inboundPool; },


  _parseFrontendIP: function _parseFrontendIP__30(resourceGroupName, frontendIPConfig, options, _) { var self, subnetIdOpt, publicIpIdOpt, hasPublicIP, subnet, publicip, privateIpAddressOpt, __this = this; var __frame = { name: "_parseFrontendIP__30", line: 1112 }; return __func(_, this, arguments, _parseFrontendIP__30, 3, __frame, function __$_parseFrontendIP__30() { self = __this;

      if ((options.privateIpAddress && options.publicIpName)) {
        return _(new Error($("Both optional parameters --private-ip-address and --public-ip-name cannot be specified together"))); } ;


      if ((options.privateIpAddress && options.publicIpId)) {
        return _(new Error($("Both optional parameters --private-ip-address and --public-ip-id cannot be specified together"))); } ;


      if ((options.publicIpName && options.publicIpId)) {
        return _(new Error($("Both optional parameters --public-ip-name and --public-ip-id cannot be specified together"))); } ;


      if ((options.subnetName && options.subnetId)) {
        return _(new Error($("Both optional parameters --subnet-name and --subnet-id cannot be specified together"))); } ;


      if (!options.subnetId) {
        if (options.subnetName) {
          if (!options.vnetName) {
            return _(new Error($("You must specify subnet virtual network (vnet-name) if subnet name (subnet-name)  is provided"))); } ; } ;



        if (options.vnetName) {
          if (!options.subnetName) {
            return _(new Error($("You must specify  subnet name (subnet-name) if subnet virtual network (vnet-name) is provided"))); } ; } ; } ;




      subnetIdOpt = null;
      publicIpIdOpt = null;
      hasPublicIP = false; return (function __$_parseFrontendIP__30(__then) {

        if ((options.subnetName || options.subnetId)) {
          frontendIPConfig.subnet = { }; return (function __$_parseFrontendIP__30(__then) {
            if (options.subnetId) {
              subnetIdOpt = utils.getOptionalArg(options.subnetId);
              if (subnetIdOpt.value) {
                frontendIPConfig.subnet.id = subnetIdOpt.value.replace(/'|""/gm, ""); }
               else {
                delete frontendIPConfig.subnet; } ; __then(); } else {


              return self.subnetCrud.get(resourceGroupName, options.vnetName, options.subnetName, __cb(_, __frame, 46, 37, function ___(__0, __1) { subnet = __1;
                if (!subnet) {
                  return _(new Error(util.format($("Subnet with name \"%s\" not found"), options.subnetName))); } ;

                frontendIPConfig.subnet.id = subnet.id; __then(); }, true)); } ; })(__then); } else { __then(); } ; })(function __$_parseFrontendIP__30() { return (function __$_parseFrontendIP__30(__then) {



          if ((options.publicIpName || options.publicIpId)) {
            frontendIPConfig.publicIpAddress = { }; return (function __$_parseFrontendIP__30(__then) {
              if (options.publicIpId) {
                publicIpIdOpt = utils.getOptionalArg(options.publicIpId);
                if (publicIpIdOpt.value) {
                  frontendIPConfig.publicIpAddress.id = publicIpIdOpt.value.replace(/'|""/gm, "");
                  hasPublicIP = true; }
                 else {
                  delete frontendIPConfig.publicIpAddress; } ; __then(); } else {


                return self.publicIpCrud.get(resourceGroupName, options.publicIpName, __cb(_, __frame, 65, 41, function ___(__0, __2) { publicip = __2;
                  if (!publicip) {
                    return _(new Error(util.format($("Public IP \"%s\" not found"), options.publicIpName))); } ;


                  frontendIPConfig.publicIpAddress.id = publicip.id;
                  hasPublicIP = true; __then(); }, true)); } ; })(__then); } else { __then(); } ; })(function __$_parseFrontendIP__30() {



          privateIpAddressOpt = utils.getOptionalArg(options.privateIpAddress);
          if (hasPublicIP) {
            delete frontendIPConfig.privateIpAddress;
            delete frontendIPConfig.privateIpAllocationMethod; } ;


          if (privateIpAddressOpt.hasValue) {
            if (privateIpAddressOpt.value) {
              frontendIPConfig.privateIpAddress = privateIpAddressOpt.value;
              frontendIPConfig.privateIpAllocationMethod = "Static"; }
             else {
              delete frontendIPConfig.privateIpAddress;
              frontendIPConfig.privateIpAllocationMethod = "Dynamic"; } ; } ;



          return _(null, frontendIPConfig); }); }); }); }});



module.exports = LoadBalancer;
