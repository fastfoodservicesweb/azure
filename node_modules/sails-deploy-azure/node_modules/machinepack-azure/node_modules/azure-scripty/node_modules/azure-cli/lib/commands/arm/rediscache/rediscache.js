/*** Generated by streamline 0.10.17 (callbacks) - DO NOT EDIT ***/ "use strict"; var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; var util = require("util");




























var profile = require("../../../util/profile");
var utils = require("../../../util/utils");
var rediscacheUtils = require("./rediscacheUtils");
var resourceUtils = require("../resource/resourceUtils");

var $ = utils.getLocaleString;



var SKU_TYPE = ["Basic","Standard",];
var VM_SIZE = ["C0","C1","C2","C3","C4","C5","C6",];
var KEY_TYPE = ["Primary","Secondary",];
var MAX_MEMORY_POLICY = ["AllKeysLRU","AllKeysRandom","NoEviction","VolatileLRU","VolatileRandom","VolatileTTL",];
var DefaultRedisVersion = "3.0";

exports.init = function(cli) {
  var log = cli.output;
  var rediscache = cli.category("rediscache").description($("Commands to manage your Azure Redis Cache(s)"));



  rediscache.command("create [name] [resource-group] [location]").description($("Create a Redis Cache")).usage("[--name <name> --resource-group <resource-group> --location <location> [options]]").option("-n, --name <name>", $("Name of the Redis Cache.")).option("-g, --resource-group <resource-group>", $("Name of the Resource Group")).option("-l, --location <location>", $("Location to create cache.")).option("-z, --size <size>", util.format($("Size of the Redis Cache. Valid values: [%s]"), VM_SIZE.join(", "))).option("-x, --sku <sku>", util.format($("Redis SKU. Should be one of : [%s]"), SKU_TYPE.join(", "))).option("-m, --max-memory-policy <max-memory-policy>", util.format($("MaxMemoryPolicy property of the Redis Cache. Valid values: [%s]"), MAX_MEMORY_POLICY.join(", "))).option("-e, --enable-non-ssl-port", $("EnableNonSslPort property of the Redis Cache. Add this flag if you want to enable the Non SSL Port for your cache")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __1(name, resourceGroup, location, options, _) { var skuFamily, skuCapacity, subscription, client, checkRedisCacheProgress, redisCacheNameExists, skuProperties, redisProperties, redisConfig, parameters, progress, result; var __frame = { name: "__1", line: 62 }; return __func(_, this, arguments, __1, 4, __frame, function __$__1() {
















      log.verbose(("arguments: " + JSON.stringify({
        name: name,
        options: options })));


      options.name = (options.name || name);
      options.resourceGroup = (options.resourceGroup || resourceGroup);
      options.location = (options.location || location);


      if (!options.name) {
        return _(null, cli.missingArgument("name")); } else {
        if (!options.resourceGroup) {
          return _(null, cli.missingArgument("resource-group")); } else {
          if (!options.location) {
            return _(null, cli.missingArgument("location")); } ; } ; } ;


      if (options.enableNonSslPort) {
        options.enableNonSslPort = true; }

       else {
        options.enableNonSslPort = false; } ;


      options.sku = rediscacheUtils.parseEnumArgument("sku", options.sku, SKU_TYPE, SKU_TYPE[1]);
      options.size = rediscacheUtils.parseEnumArgument("size", options.size, VM_SIZE, VM_SIZE[1]);
      options.maxMemoryPolicy = rediscacheUtils.parseEnumArgument("max-memory-policy", options.maxMemoryPolicy, MAX_MEMORY_POLICY, MAX_MEMORY_POLICY[0]);
      options.size = rediscacheUtils.getSizeRedisSpecific(options.size);


      skuFamily = options.size.substring(0, 1);
      skuCapacity = parseInt(options.size.substring(1));






      subscription = profile.current.getSubscription();
      client = utils.createRedisCacheManagementClient(subscription);





      checkRedisCacheProgress = cli.interaction.progress(util.format($("")));
      redisCacheNameExists = null; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__1() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__1() {

                  return client.redis.get(options.resourceGroup, options.name, __cb(_, __frame, 55, 42, function ___(__0, __1) { redisCacheNameExists = __1.resource; __then(); }, true)); }); })(function ___(e, __result) { __catch(function __$__1() { if (e) {

                    if (!(((e.code === "ResourceNotFound") || (e.code === "ResourceGroupNotFound")))) {
                      return _(e); } ; __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$__1() { _(null, null, true); }); }); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__1() {



              checkRedisCacheProgress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__1() {


          if (redisCacheNameExists) {
            return _(new Error(util.format($("The requested cache name is unavailable: %s"), options.name))); } ;





          skuProperties = {
            capacity: skuCapacity,
            family: skuFamily,
            name: options.sku };


          redisProperties = null;
          if (!options.maxMemoryPolicy) {
            redisProperties = {
              redisVersion: DefaultRedisVersion,
              enableNonSslPort: options.enableNonSslPort,
              sku: skuProperties }; }


           else {
            options.maxMemoryPolicy = rediscacheUtils.parseEnumArgument("max-memory-policy", options.maxMemoryPolicy, MAX_MEMORY_POLICY, MAX_MEMORY_POLICY[0]);
            options.maxMemoryPolicy = rediscacheUtils.getMaxMemoryPolicy(options.maxMemoryPolicy);
            redisConfig = { };
            redisConfig["maxmemory-policy"] = options.maxMemoryPolicy;
            redisProperties = {
              redisVersion: DefaultRedisVersion,
              redisConfiguration: redisConfig,
              enableNonSslPort: options.enableNonSslPort,
              sku: skuProperties }; } ;



          parameters = {
            location: options.location,
            properties: redisProperties };


          progress = cli.interaction.progress(util.format($("Attempting to create Redis Cache %s ..."), options.name)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__1() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__1() {


                      return client.redis.createOrUpdate(options.resourceGroup, options.name, parameters, __cb(_, __frame, 107, 28, function ___(__0, __2) { result = __2.resource; __then(); }, true)); }); })(function ___(e, __result) { __catch(function __$__1() { if (e) {


                        if ((e.code === "NameNotAvailable")) {
                          return _(new Error(util.format($("The requested cache name is unavailable: %s"), options.name))); }

                         else {
                          return _(e); } ; __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$__1() { _(null, null, true); }); }); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__1() {



                  progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__1() {


              cli.interaction.formatOutput(result, function(data) {
                if (!data) {
                  log.info($("No Redis Cache information available")); }
                 else {
                  log.data("");
                  log.data($("Provisioning State :"), result.properties.provisioningState);
                  log.data("");
                  log.data($("Cache Name         :"), result.name);
                  log.data($("Resource Group     :"), options.resourceGroup);
                  log.data($("Location           :"), result.location);
                  log.data($("Host Name          :"), result.properties.hostName);
                  log.data($("Port               :"), result.properties.port);
                  log.data($("SSL Port           :"), result.properties.sslPort);
                  log.data($("Non SSL Enabled    :"), result.properties.enableNonSslPort.toString());
                  log.data($("Redis Version      :"), result.properties.redisVersion);
                  log.data($("Max Memory Policy  :"), result.properties.redisConfiguration["maxmemory-policy"]);
                  log.data($("Sku                :"), result.properties.sku.name);
                  log.data($("Size               :"), (result.properties.sku.family + result.properties.sku.capacity.toString()));
                  log.data($("Id                 :"), result.id);
                  log.data(""); } ; });



              if ((result.statusCode == 200)) {
                log.info((("Redis Cache " + options.name) + " is getting created...")); } ; _(); }); }); }); }); }); });





  rediscache.command("delete [name] [resource-group]").description($("Delete an existing Redis Cache")).usage("[--name <name> --resource-group <resource-group> ]").option("-n, --name <name>", $("Name of the Redis Cache.")).option("-g, --resource-group <resource-group>", $("Name of the Resource Group under which the cache exists")).option("-s, --subscription <subscription>", $("the subscription identifier")).execute(function __2(name, resourceGroup, options, _) { var subscription, client, SeeIfCacheExists, progress, result; var __frame = { name: "__2", line: 219 }; return __func(_, this, arguments, __2, 3, __frame, function __$__2() {











      log.verbose(("arguments: " + JSON.stringify({
        name: name,
        options: options })));


      options.name = (options.name || name);
      options.resourceGroup = (options.resourceGroup || resourceGroup);

      if (!options.name) {
        return _(null, cli.missingArgument("name")); } else {
        if (!options.resourceGroup) {
          return _(null, cli.missingArgument("resource-group")); } ; } ;






      subscription = profile.current.getSubscription();
      client = utils.createRedisCacheManagementClient(subscription);





      SeeIfCacheExists = null; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__2() {

            return client.redis.get(options.resourceGroup, options.name, __cb(_, __frame, 33, 38, function ___(__0, __1) { SeeIfCacheExists = __1.resource; __then(); }, true)); }); })(function ___(e, __result) { __catch(function __$__2() { if (e) {


              if ((e.code === "ResourceNotFound")) {
                return _(new Error(rediscacheUtils.showNotFoundError(options.resourceGroup, options.name))); }

               else {
                return _(e); } ; __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$__2() {







          progress = cli.interaction.progress(util.format($("Deleting Redis Cache %s"), options.name)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__2() {


                return client.redis.deleteMethod(options.resourceGroup, options.name, __cb(_, __frame, 51, 28, function ___(__0, __2) { result = __2; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__2() {

                  progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__2() {



              if ((result.statusCode == 200)) {
                log.info(("Delete command successfully invoked for Redis Cache " + options.name)); } ; _(); }); }); }); }); }); });




  rediscache.command("list").description($("List all Redis Caches within your Subscription or Resource Group")).usage("[options]").option("-g, --resource-group <resource-group>", $("Name of the Resource Group")).option("-s, --subscription <subscription>", $("the subscription identifier")).execute(function __3(options, _) { var subscription, client, operation, progress, result, i; var __frame = { name: "__3", line: 287 }; return __func(_, this, arguments, __3, 1, __frame, function __$__3() {










      subscription = profile.current.getSubscription();
      client = utils.createRedisCacheManagementClient(subscription);





      return client.redis.list(options.resourceGroup, __cb(_, __frame, 13, 33, function ___(__0, __1) { operation = __1.value;

        progress = cli.interaction.progress(util.format($("Getting Redis Cache(s) "))); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__3() {


              result = operation;
              for (i = 0; (i < result.length); ++i) {
                result[i].resourceGroup = resourceUtils.getResourceInformation(result[i].id).resourceGroup; }; _(null, null, true); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__3() {


                progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__3() {


            if ((result.length === 0)) {
              log.info($("No redis caches found.")); }
             else {
              log.table(result, function(row, item) {
                row.cell($("Name"), item.name);
                row.cell($("Resource Group"), item.resourceGroup);
                row.cell($("Location"), item.location);
                row.cell($("Host Name"), item.properties.hostName);
                row.cell($("Port"), item.properties.port);
                row.cell($("ProvisioningState"), item.properties.provisioningState);
                row.cell($("SSL Port"), item.properties.sslPort);
                row.cell($("Non SSL Enabled"), item.properties.enableNonSslPort);
                row.cell($("Redis Version"), item.properties.redisVersion);
                row.cell($("Max Memory Policy"), item.properties.redisConfiguration["maxmemory-policy"]);
                row.cell($("Sku"), item.properties.sku.name);
                row.cell($("Size"), (item.properties.sku.family + item.properties.sku.capacity.toString()));
                row.cell($("Id"), item.id); }); } ;



            log.info("Redis Cache Details"); _(); }); }); }, true)); }); });



  rediscache.command("show [name] [resource-group]").description($("Show properties of an existing Redis Cache")).usage("[--name <name> --resource-group <resource-group>]").option("-n, --name <name>", $("Name of the Redis Cache.")).option("-g, --resource-group <resource-group>", $("Name of the Resource Group")).option("-s, --subscription <subscription>", $("the subscription identifier")).execute(function __4(name, resourceGroup, options, _) { var subscription, client, operation, progress, result; var __frame = { name: "__4", line: 343 }; return __func(_, this, arguments, __4, 3, __frame, function __$__4() {







      log.verbose(("arguments: " + JSON.stringify({
        name: name,
        options: options })));


      options.name = (options.name || name);
      options.resourceGroup = (options.resourceGroup || resourceGroup);

      if (!options.name) {
        return _(null, cli.missingArgument("name")); } else {
        if (!options.resourceGroup) {
          return _(null, cli.missingArgument("resource-group")); } ; } ;






      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createRedisCacheManagementClient(subscription);





      operation = null; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__4() {

            return client.redis.get(options.resourceGroup, options.name, __cb(_, __frame, 29, 31, function ___(__0, __1) { operation = __1.resource; __then(); }, true)); }); })(function ___(e, __result) { __catch(function __$__4() { if (e) {


              if ((e.code === "ResourceNotFound")) {
                return _(new Error(rediscacheUtils.showNotFoundError(options.resourceGroup, options.name))); }

               else {
                return _(e); } ; __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$__4() {







          progress = cli.interaction.progress(util.format($("Getting Redis Cache(s) "))); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__4() {


                result = operation;
                result.resourceGroup = resourceUtils.getResourceInformation(result.id).resourceGroup; _(null, null, true); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__4() {

                  progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__4() {


              cli.interaction.formatOutput(result, function(data) {
                if (!data) {
                  log.info($("No Redis Cache information available")); }
                 else {
                  log.data($("Cache Name         :"), result.name);
                  log.data($("Resource Group     :"), result.resourceGroup);
                  log.data($("Location           :"), result.location);
                  log.data($("Host Name          :"), result.properties.hostName);
                  log.data($("Port               :"), result.properties.port);
                  log.data($("Provisioning State :"), result.properties.provisioningState);
                  log.data($("SSL Port           :"), result.properties.sslPort);
                  log.data($("Non SSL Enabled    :"), result.properties.enableNonSslPort.toString());
                  log.data($("Redis Version      :"), result.properties.redisVersion);
                  log.data($("Max Memory Policy  :"), result.properties.redisConfiguration["maxmemory-policy"]);
                  log.data($("Sku                :"), result.properties.sku.name);
                  log.data($("Size               :"), (result.properties.sku.family + result.properties.sku.capacity.toString()));
                  log.data($("Id                 :"), result.id);
                  log.data(""); } ; });



              log.info("Redis Cache Details"); _(); }); }); }); }); }); });



  rediscache.command("set [name] [resource-group] [max-memory-policy]").description($("Change settings of an existing Redis Cache")).usage("[--name <name> --resource-group <resource-group> --max-memory-policy <max-memory-policy>]").option("-n, --name <name>", $("Name of the Redis Cache.")).option("-g, --resource-group <resource-group>", $("Name of the Resource Group")).option("-m, --max-memory-policy <max-memory-policy>", util.format($("Max Memory Policy of the Redis Cache. Valid values: [%s]"), MAX_MEMORY_POLICY.join(", "))).option("-s, --subscription <subscription>", $("the subscription identifier")).execute(function __5(name, resourceGroup, maxMemoryPolicy, options, _) { var subscription, client, progress, operation, result, skuProperties, redisConfig, redisProperties, parameters, updateProgress, updateResult; var __frame = { name: "__5", line: 428 }; return __func(_, this, arguments, __5, 4, __frame, function __$__5() {








      log.verbose(("arguments: " + JSON.stringify({
        name: name,
        options: options })));


      options.name = (options.name || name);
      options.resourceGroup = (options.resourceGroup || resourceGroup);
      options.maxMemoryPolicy = (options.maxMemoryPolicy || maxMemoryPolicy);

      if (!options.name) {
        return _(null, cli.missingArgument("name")); } else {
        if (!options.resourceGroup) {
          return _(null, cli.missingArgument("resource-group")); } else {
          if (!options.maxMemoryPolicy) {
            return _(null, cli.missingArgument("max-memory-policy")); } ; } ; } ;


      options.maxMemoryPolicy = rediscacheUtils.parseEnumArgument("max-memory-policy", options.maxMemoryPolicy, MAX_MEMORY_POLICY, MAX_MEMORY_POLICY[0]);
      options.maxMemoryPolicy = rediscacheUtils.getMaxMemoryPolicy(options.maxMemoryPolicy);





      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createRedisCacheManagementClient(subscription);





      progress = cli.interaction.progress(util.format($("Getting Redis Cache(s) ")));
      operation = null; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__5() {

            return client.redis.get(options.resourceGroup, options.name, __cb(_, __frame, 36, 31, function ___(__0, __1) { operation = __1.resource; __then(); }, true)); }); })(function ___(e, __result) { __catch(function __$__5() { if (e) {


              if ((e.code === "ResourceNotFound")) {
                return _(new Error(rediscacheUtils.showNotFoundError(options.resourceGroup, options.name))); }

               else {
                return _(e); } ; __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$__5() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__5() {





                result = operation;
                result.resourceGroup = resourceUtils.getResourceInformation(result.id).resourceGroup; _(null, null, true); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__5() {

                  progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__5() {


              skuProperties = {
                capacity: result.properties.sku.capacity,
                family: result.properties.sku.family,
                name: result.properties.sku.name };


              redisConfig = { };
              redisConfig["maxmemory-policy"] = options.maxMemoryPolicy;

              redisProperties = {
                redisVersion: result.properties.redisVersion,
                redisConfiguration: redisConfig,
                enableNonSslPort: result.properties.enableNonSslPort,
                sku: skuProperties };


              parameters = {
                location: result.location,
                properties: redisProperties };


              updateProgress = cli.interaction.progress(util.format($("Updating Redis Cache %s ..."), options.name)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__5() {


                    return client.redis.createOrUpdate(options.resourceGroup, options.name, parameters, __cb(_, __frame, 79, 34, function ___(__0, __2) { updateResult = __2.resource; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__5() {

                      updateProgress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__5() {


                  cli.interaction.formatOutput(updateResult, function(data) {
                    if (!data) {
                      log.info($("No Redis Cache information available")); }
                     else {
                      log.data($("Provisioning State :"), updateResult.properties.provisioningState);
                      log.data("");
                      log.data($("Cache Name         :"), updateResult.name);
                      log.data($("Resource Group     :"), updateResult.resourceGroup);
                      log.data($("Location           :"), updateResult.location);
                      log.data($("Host Name          :"), updateResult.properties.hostName);
                      log.data($("Port               :"), updateResult.properties.port);
                      log.data($("SSL Port           :"), updateResult.properties.sslPort);
                      log.data($("Non SSL Enabled    :"), updateResult.properties.enableNonSslPort.toString());
                      log.data($("Redis Version      :"), updateResult.properties.redisVersion);
                      log.data($("Max Memory Policy  :"), updateResult.properties.redisConfiguration["maxmemory-policy"]);
                      log.data($("Sku                :"), updateResult.properties.sku.name);
                      log.data($("Size               :"), (updateResult.properties.sku.family + updateResult.properties.sku.capacity.toString()));
                      log.data($("Id                 :"), updateResult.id);
                      log.data(""); } ; });



                  log.info((("Redis Cache " + options.name) + " is getting updated ")); _(); }); }); }); }); }); }); }); });




  rediscache.command("renew-key [name] [resource-group]").description($("Renew the authentication key for an existing Redis Cache")).usage("[--name <name> --resource-group <resource-group> ]").option("-n, --name <name>", $("Name of the Redis Cache.")).option("-g, --resource-group <resource-group>", $("Name of the Resource Group under which cache exists")).option("-t, --key-type <key-type>", $("type of key to renew")).option("-s, --subscription <subscription>", $("the subscription identifier")).execute(function __6(name, resourceGroup, options, _) { var subscription, client, parameters, SeeIfCacheExists, progress, result, finalKeys; var __frame = { name: "__6", line: 546 }; return __func(_, this, arguments, __6, 3, __frame, function __$__6() {












      log.verbose(("arguments: " + JSON.stringify({
        name: name,
        options: options })));


      options.name = (options.name || name);
      options.resourceGroup = (options.resourceGroup || resourceGroup);

      if (!options.name) {
        return _(null, cli.missingArgument("name")); } else {
        if (!options.resourceGroup) {
          return _(null, cli.missingArgument("resource-group")); } ; } ;


      options.keyType = rediscacheUtils.parseEnumArgument("key-type", options.keyType, KEY_TYPE, KEY_TYPE[0]);






      subscription = profile.current.getSubscription();
      client = utils.createRedisCacheManagementClient(subscription);

      parameters = {
        keyType: options.keyType };






      SeeIfCacheExists = null; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__6() {

            return client.redis.get(options.resourceGroup, options.name, __cb(_, __frame, 40, 38, function ___(__0, __1) { SeeIfCacheExists = __1.resource; __then(); }, true)); }); })(function ___(e, __result) { __catch(function __$__6() { if (e) {


              if ((e.code === "ResourceNotFound")) {
                return _(new Error(rediscacheUtils.showNotFoundError(options.resourceGroup, options.name))); }

               else {
                return _(e); } ; __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$__6() {







          progress = cli.interaction.progress(util.format($("Renewing %s key for Redis Cache %s"), options.keyType.toString(), options.name)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__6() {


                return client.redis.regenerateKey(options.resourceGroup, options.name, parameters, __cb(_, __frame, 58, 28, function ___(__0, __2) { result = __2; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__6() {

                  progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__6() {


              finalKeys = null; return (function __$__6(__then) {
                if ((result.statusCode == 200)) {
                  return client.redis.listKeys(options.resourceGroup, options.name, __cb(_, __frame, 65, 31, function ___(__0, __3) { finalKeys = __3;
                    cli.interaction.formatOutput(finalKeys, function(data) {
                      if (!data) {
                        log.info($("No Redis Cache information available")); }
                       else {
                        log.data($("Primary Key   :"), finalKeys.primaryKey);
                        log.data($("Secondary Key :"), finalKeys.secondaryKey);
                        log.data(""); } ; }); __then(); }, true)); } else {




                  log.error(("Could not renew key for Redis Cache " + options.name)); __then(); } ; })(function __$__6() {


                log.info(((options.keyType + " Key renewed for Redis Cache ") + options.name)); _(); }); }); }); }); }); }); });



  rediscache.command("list-keys [name] [resource-group]").description($("Lists Primary and Secondary key of an existing Redis Cache")).usage("[--name <name> --resource-group <resource-group>]").option("-n, --name <name>", $("Name of the Redis Cache.")).option("-g, --resource-group <resource-group>", $("Name of the Resource Group under which Cache exists")).option("-s, --subscription <subscription>", $("the subscription identifier")).execute(function __7(name, resourceGroup, options, _) { var subscription, client, SeeIfCacheExists, progress, result; var __frame = { name: "__7", line: 636 }; return __func(_, this, arguments, __7, 3, __frame, function __$__7() {











      log.verbose(("arguments: " + JSON.stringify({
        name: name,
        options: options })));


      options.name = (options.name || name);
      options.resourceGroup = (options.resourceGroup || resourceGroup);

      if (!options.name) {
        return _(null, cli.missingArgument("name")); } else {
        if (!options.resourceGroup) {
          return _(null, cli.missingArgument("resource-group")); } ; } ;







      subscription = profile.current.getSubscription();
      client = utils.createRedisCacheManagementClient(subscription);





      SeeIfCacheExists = null; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__7() {

            return client.redis.get(options.resourceGroup, options.name, __cb(_, __frame, 34, 38, function ___(__0, __1) { SeeIfCacheExists = __1.resource; __then(); }, true)); }); })(function ___(e, __result) { __catch(function __$__7() { if (e) {


              if ((e.code === "ResourceNotFound")) {
                return _(new Error(rediscacheUtils.showNotFoundError(options.resourceGroup, options.name))); }

               else {
                return _(e); } ; __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$__7() {







          progress = cli.interaction.progress(util.format($("Getting keys for Redis Cache %s ..."), options.name)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__7() {


                return client.redis.listKeys(options.resourceGroup, options.name, __cb(_, __frame, 52, 28, function ___(__0, __2) { result = __2; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__7() {

                  progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__7() {


              cli.interaction.formatOutput(result, function(data) {
                if (!data) {
                  log.info($("No Redis Cache information available")); }
                 else {
                  log.data($("Primary Key   :"), result.primaryKey);
                  log.data($("Secondary Key :"), result.secondaryKey);
                  log.data(""); } ; });



              log.info((" Keys for Redis Cache " + options.name)); _(); }); }); }); }); }); });};
